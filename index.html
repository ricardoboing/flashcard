<html>
<head>
	<title>FlashCard</title>

	<style type="text/css">
		div.center {
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100%;
		}
		button {
			float: left;
			padding: 15px 20px;
			font-weight: bold;
		}
		button.green {
			background-color: green;
			border: 3px darkgreen solid;
			color: white;
			margin-left: 2px;
		}
		button.blue {
			background-color: blue;
			border: 3px darkblue solid;
			color: white;
		}
		span#card {
			font-size: 1000%;
			color: rgb(200,0,0);
		}
		span#meaning {
			font-size: 500%;
		}
		span#meaning.hide {
			color: white;
		}
		span#meaning.visible {
			color: rgb(0,0,200);
		}
		span {
			font-weight: bold;
		}
		div.table {
			margin: 0 auto;
			display: flex;
			align-items: center;
			text-align: center;
			flex-direction: column;
		}
		div.main {
			margin: 0 auto;
			display: flex;
			flex: 0;
			height: 100%;
			justify-content: center;
			align-items: center;
		}
		div.meaning {
			background-color: white;
		}
		input {
			width: 600px;
			height: 70px;
			font-size: 50px;
			border-color: black;
			border-width: 3px;
			border-style: solid;
			color: black;
			text-align: center;
		}
		input.wrong {
			border: thick solid yellow;
			color: yellow;
			outline-color: rgb(215,215,0);
		}
		input.correct {
			border: thick solid blue;
			color: blue;
			outline: none;
		}
		input.not_answered {
			outline-color: rgb(20,20,20);
		}
		div#flashcard, div#menu {
			display: none;
		}
	</style>
</head>
<body>
	<div class="main">
		<div class="table">
			<div id="file">
				<input id="input_file" type="file">
			</div>
			<div id="menu">
				<button class="blue">Old deck</button>
				<button class="green">New deck</button>
			</div>
			<div id="flashcard">
				<div>
					<span id="card">START</span>
				</div>
				<div class="meaning">
					<span id="meaning">-----</span>
				</div>
				<div>
					<input id="answer" class="not_answered" type="text" autocomplete="off">
				</div>
			</div>
		</div>
	</div>
</body>
<!--
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
<script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>

<script type="text/babel">

</script>
-->
<script type="text/javascript">
	var LIMIT_WORD_FOR_DAY = 250;

	var oldDeck = [];
	var newDeck = [];
	var deck = [];

	var card = document.getElementById("card");
	var meaning = document.getElementById("meaning");
	var answer = document.getElementById("answer");
	
	var pointer = 0;
	var limitInf = 0;
	var limitSup = 0;

	var headerFile = "Card,Meaning,Score,Consecutive hits,Consecutive miss,Repeat word?";
	var deckSeparator = "OldDeck,,,,,";
	
	var showMeaning = false;
	var typeDeck = null;

	var finish = false;

	function set_deck(_deck) {
		for (var i = 0; i < LIMIT_WORD_FOR_DAY && _deck.length > 0; i++) {
			deck[i] = _deck[0];
			_deck.shift();
		}
		shuffleArray(deck);

		limitSup = deck.length;

		show_flashcard();
		update_card(deck);
		hide_meaning();
	}
	document.getElementById("menu").children[0].addEventListener("click", function() {
		set_deck(oldDeck);
		typeDeck = "old";
	});
	document.getElementById("menu").children[1].addEventListener("click", function() {
		set_deck(newDeck);
		typeDeck = "new";
	});

	document.getElementById('input_file').addEventListener('change', function() {
		var fr = new FileReader();

		fr.onload = function() {
			load_database(fr.result);
		}

		fr.readAsText(this.files[0]);
		show_menu();
	});

	function load_database(database) {
		var decks = database.split(deckSeparator);

		load_deck(newDeck, decks[0].split("\n"));
		load_deck(oldDeck, decks[1].split("\n"));

		check_repeat_word();
	}
	function check_repeat_word() {
		var existsRepeat = false;

		for (var i = 0; i < oldDeck.length; i++) {
			for (var j = i+1; j < oldDeck.length; j++) {
				if (oldDeck[i][1] == oldDeck[j][1]) {
					oldDeck[i][6] = "*";
					oldDeck[j][6] = "*";
					existsRepeat = true;
				}
			}
			for (var j = 0; j < newDeck.length; j++) {
				if (oldDeck[i][1] == newDeck[j][1]) {
					oldDeck[i][6] = "*";
					newDeck[j][6] = "*";
					existsRepeat = true;
				}
			}
		}
		for (var i = 0; i < newDeck.length; i++) {
			for (var j = i+1; j < newDeck.length; j++) {
				if (newDeck[i][1] == newDeck[j][1]) {
					oldDeck[i][6] = "*";
					oldDeck[j][6] = "*";
					existsRepeat = true;
				}
			}
		}

		if (existsRepeat) {
			alert("There are one or more repeated words. Please check the deck.");
		}
	}
	function load_deck(_deck, _lines) {
		for (var i = 1; i < _lines.length; i++) {
			if (_lines[i] == "") {
				continue;
			}

			var line = _lines[i].split(",");
			
			// Card, Meaning, Hit/Miss, Score, Consecutive hits, Consecutives miss
			var cardValue = [line[0], line[1], 2, parseInt(line[2]), parseInt(line[3]), parseInt(line[4]), ""];
			
			_deck.push(cardValue);
		}

		bubbleSort(_deck);
	}
	function update_database() {
		var file_name = "database.csv";
		var data = headerFile+"\n";

		data += format_deck(newDeck);
		if (typeDeck == "new") {
			data += format_deck(deck);
			data += deckSeparator+"\n";
		} else {
			data += deckSeparator+"\n";
			data += format_deck(deck);
		}
		data += format_deck(oldDeck);

		const a = document.createElement("a");
		const file = new Blob([data], {type: 'text/plain'});

		a.href= URL.createObjectURL(file);
		a.download = file_name;
		a.click();

		URL.revokeObjectURL(a.href);
	}
	function format_deck(_deck) {
		var data = "";
		for (var i = 0; i < _deck.length; i++) {
			var word = _deck[i][0];
			var meaning = _deck[i][1];
			var progress = parseInt(_deck[i][2]);
			var score = parseInt(_deck[i][3]);
			var consecutiveHit = parseInt(_deck[i][4]);
			var consecutiveMiss = parseInt(_deck[i][5]);
			var repeated = _deck[i][6];

			if (progress == 0) {
				consecutiveHit = -1;
				consecutiveMiss++;
				score -= 3*(consecutiveMiss+1);
			} else if (progress == 1) {
				consecutiveHit++;
				consecutiveMiss = -1;
				score += 2*(consecutiveHit+1);
			}

			data += word+","+meaning+","+score+","+consecutiveHit+","+consecutiveMiss+","+repeated+"\n";
		}

		return data;
	}

	function show_menu() {
		document.getElementById("file").style.display = "none";
		document.getElementById("menu").style.display = "block";
	}
	function show_flashcard() {
		document.getElementById("menu").style.display = "none";
		document.getElementById("flashcard").style.display = "block";
	}
	function get_answers() {
		var _answer = answer.value.toLowerCase();
		return _answer.split("/");
	}
	function get_meanings() {
		var _meaning = meaning.innerText.toLowerCase();
		return _meaning.split("/");
	}

	function is_answered() {
		if (answer.value == "") {
			return false;
		}
		return true;
	}

	function add_class(_element, _class) {
		_element.classList.add(_class);
	}
	function remove_class(_element, _class) {
		_element.classList.remove(_class);
	}
	
	function set_corret_answer() {
		add_class(answer, "correct");
		remove_class(answer, "wrong");
		remove_class(answer, "not_answered");
	}
	function set_wrong_answer() {
		remove_class(answer, "correct");
		add_class(answer, "wrong");
		remove_class(answer, "not_answered");
	}
	function clear_answer() {
		answer.value = "";

		remove_class(answer, "correct");
		remove_class(answer, "wrong");
		add_class(answer, "not_answered");
	}

	function show_meaning() {
		add_class(meaning, "visible");
		remove_class(meaning, "hide");
		showMeaning = true;
	}
	function hide_meaning() {
		add_class(meaning, "hide");
		remove_class(meaning, "visible");
		showMeaning = false;
		verifyAnswer = false;		
	}
	
	// Algoritmo was get in the web
	function shuffleArray(_array) {
		for (var i = _array.length - 1; i > 0; i--) {
			var j = Math.floor(Math.random() * (i + 1));
			var temp = _array[i];
			_array[i] = _array[j];
			_array[j] = temp;
		}
	}
	// Algoritmo was get in the web
	function bubbleSort(_array) {
		n = _array.length;

		for (var i = 0; i < n; i++) {
			for (var j = 0; j < n-i-1; j++) {
				if (_array[j][3] > _array[j+1][3]) {
					aux = _array[j];
					_array[j] = _array[j+1];
					_array[j+1] = aux;
				}
			}
		}
	}

	function update_card() {
		if (pointer == limitSup) {
			card.innerText = "END";
			meaning.innerText = "---";
			return;
		}

		card.innerText = deck[pointer][0];
		meaning.innerText = deck[pointer][1];
	}
	function verify_answer() {
		answers = get_answers();
		meanings = get_meanings();

		var correct = false;

		for (var i = 0; i < answers.length; i++) {
			correct = false;
			for (var j = 0; j < meanings.length; j++) {
				if (answers[i] == meanings[j]) {
					correct = true;
					break;
				}
			}
			
			if (!correct) {
				return false;
			}
		}

		if (!correct) {
			return false;
		}

		return true;
	}

	function previous_word() {
		pointer--;
		if (pointer < limitInf) {
			pointer = limitInf;
		}
		clear_answer();
		hide_meaning();
		update_card();
	}
	function next_old_deck() {
		if (!finish) {
			pointer++;
		} else {
			auxPointer = pointer+1;
			pointer = limitSup;

			if (auxPointer >= limitSup) {
				auxPointer = limitInf;
			}
			// Check words after the current
			for (var i = auxPointer; i < limitSup; i++) {
				if (deck[i][2] == 0) {
					pointer = i;
					break;
				}
			}
			// If all after the word is ok, check the words before the current
			if (pointer == limitSup) {
				for (var i = 0; i <= auxPointer; i++) {
					if (deck[i][2] == 0) {
						pointer = i;
						break;
					}
				}
			}
		}

		clear_answer();
		hide_meaning();
		update_card(deck);
	}
	function event_old_deck(_key) {
		if (_key == "ArrowUp" && !finish) {
			previous_word();
			return;
		}
		if (_key == "Enter" && !is_answered()) {
			return;
		}
		if (_key == "ArrowDown" || _key == "Enter") {
			// Finished the deck and revision
			if (pointer == limitSup) {
				return;
			}
			// First wrong word after finished the deck
			if (pointer == limitInf-1) {
				next_old_deck();
				return;
			}
			// The meaning still hidden and the answer has not been checked
			if (!showMeaning) {
				show_meaning();
				var correctAnswer = verify_answer();

				if (correctAnswer) {
					set_corret_answer();
					deck[pointer][2] = 1;
				} else {
					set_wrong_answer();
					deck[pointer][2] = 0;
				}
			} else {
				next_old_deck();

				// Just finished the deck: repeat the wrong words and save the progress
				if (pointer == limitSup && !finish) {
					update_database();
					finish = true;
					pointer = limitInf-1;
				}
			}
		}
	}

	var counterNewDeck = 1;
	function next_new_deck() {
		pointer++;

		// Turn back 8 positions
		if (pointer > counterNewDeck) {
			counterNewDeck = pointer;
			pointer = counterNewDeck - 8;
			
			if (pointer < limitInf) {
				pointer = limitInf;
			}
		}
		if (counterNewDeck > limitSup) {
			pointer = limitSup;
		}

		clear_answer();
		hide_meaning();
		update_card();
	}
	function event_new_deck(_key) {
		if (_key == "Enter" && !is_answered()) {
			return;
		}
		if (_key == "ArrowDown" || _key == "Enter") {
			if (!showMeaning) {
				show_meaning();
				var correctAnswer = verify_answer();

				if (correctAnswer) {
					set_corret_answer();
					deck[pointer][2] = 1;
				} else {
					set_wrong_answer();
					deck[pointer][2] = 0;
				}
			} else {
				next_new_deck();

				if (pointer == limitSup) {
					update_database();
				}
			}
		}
	}
	function eventFunction(_event) {
		if (typeDeck == "old") {
			event_old_deck(_event.key);
		} else {
			event_new_deck(_event.key);
		}
	}

	window.addEventListener("keyup", eventFunction);
</script>
</html>