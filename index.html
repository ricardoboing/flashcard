<html>
<head>
	<title>FlashCard</title>

	<style type="text/css">
		div.center {
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100%;
		}
		button {
			float: left;
			padding: 15px 20px;
			font-weight: bold;
		}
		button.green {
			background-color: green;
			border: 3px darkgreen solid;
			color: white;
			margin-left: 2px;
		}
		button.blue {
			background-color: blue;
			border: 3px darkblue solid;
			color: white;
		}
		span#card {
			font-size: 1000%;
			color: rgb(200,0,0);
		}
		span#meaning {
			font-size: 500%;
		}
		span#meaning.hide {
			color: white;
		}
		span#meaning.visible {
			color: rgb(0,0,200);
		}
		span {
			font-weight: bold;
		}
		div.table {
			margin: 0 auto;
			display: flex;
			align-items: center;
			text-align: center;
			flex-direction: column;
		}
		div.main {
			margin: 0 auto;
			display: flex;
			flex: 0;
			height: 100%;
			justify-content: center;
			align-items: center;
		}
		div.meaning {
			background-color: white;
		}
		input {
			width: 600px;
			height: 70px;
			font-size: 50px;
			border-color: black;
			border-width: 3px;
			border-style: solid;
			color: black;
			text-align: center;
		}
		input.wrong {
			border: thick solid yellow;
			color: yellow;
			outline-color: rgb(215,215,0);
		}
		input.correct {
			border: thick solid blue;
			color: blue;
			outline: none;
		}
		input.not_answered {
			outline-color: rgb(20,20,20);
		}
		div#flashcard, div#menu {
			display: none;
		}
	</style>
</head>
<body>
	<div class="main">
		<div class="table">
			<div id="file">
				<input id="input_file" type="file">
			</div>
			<div id="menu">
				<button class="blue">Old deck</button>
				<button class="green">New deck</button>
			</div>
			<div id="flashcard">
				<div>
					<span id="card">START</span>
				</div>
				<div class="meaning">
					<span id="meaning">-----</span>
				</div>
				<div>
					<input id="answer" class="not_answered" type="text" autocomplete="off">
				</div>
			</div>
		</div>
	</div>
</body>
<!--
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
<script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>

<script type="text/babel">

</script>
-->
<script type="text/javascript">
	var oldDeck = [];
	var newDeck = [];

	var card = document.getElementById("card");
	var meaning = document.getElementById("meaning");
	var answer = document.getElementById("answer");
	
	var pointer = 0;
	var limitInf = 0;
	var limitSup = 0;

	var headerFile = "Card,Meaning,Score,Consecutive hits,Consecutive miss";
	var deckSeparator = "OldDeck,,,,";
	
	var showMeaning = false;
	var typeDeck = null;

	document.getElementById("menu").children[0].addEventListener("click", function() {
		limitSup = oldDeck.length;
		typeDeck = "old";

		show_flashcard();
		update_card(oldDeck);
		hide_meaning();
	});
	document.getElementById("menu").children[1].addEventListener("click", function() {
		limitSup = newDeck.length;
		typeDeck = "new";

		show_flashcard();
		update_card(newDeck);
		hide_meaning();
	});

	document.getElementById('input_file').addEventListener('change', function() {
		var fr = new FileReader();

		fr.onload = function() {
			load_database(fr.result);
		}

		fr.readAsText(this.files[0]);
		show_menu();
	});

	function load_database(database) {
		var decks = database.split(deckSeparator);

		load_deck(newDeck, decks[0].split("\n"));
		load_deck(oldDeck, decks[1].split("\n"));
	}
	function load_deck(_deck, _lines) {
		for (var i = 1; i < _lines.length; i++) {
			if (_lines[i] == "") {
				continue;
			}

			var line = _lines[i].split(",");
			
			// Card, Meaning, Hit/Miss, Score, Consecutive hits, Consecutives miss
			var cardValue = [line[0], line[1], 2, parseInt(line[2]), parseInt(line[3]), parseInt(line[4])];
			
			_deck.push(cardValue);
		}

		console.log(_deck);
		shuffleArray(_deck);
	}
	function update_database() {
		var file_name = "database.csv";
		var data = headerFile+"\n";

		data += format_deck(newDeck);
		data += deckSeparator+"\n";
		data += format_deck(oldDeck);

		console.log(data);

		const a = document.createElement("a");
		const file = new Blob([data], {type: 'text/plain'});

		a.href= URL.createObjectURL(file);
		a.download = file_name;
		a.click();

		URL.revokeObjectURL(a.href);
	}
	function format_deck(_deck) {
		var data = "";
		for (var i = 0; i < _deck.length; i++) {
			var word = _deck[i][0];
			var meaning = _deck[i][1];
			var progress = parseInt(_deck[i][2]);
			var score = parseInt(_deck[i][3]);
			var consecutiveHit = parseInt(_deck[i][4]);
			var consecutiveMiss = parseInt(_deck[i][5]);

			if (progress == 0) {
				consecutiveHit = -1;
				consecutiveMiss++;
				score -= 3*(consecutiveMiss+1);
			} else if (progress == 1) {
				consecutiveHit++;
				consecutiveMiss = -1;
				score += 2*(consecutiveHit+1);
			}

			data += word+","+meaning+","+score+","+consecutiveHit+","+consecutiveMiss+"\n";
		}

		return data;
	}

	function show_menu() {
		document.getElementById("file").style.display = "none";
		document.getElementById("menu").style.display = "block";
	}
	function show_flashcard() {
		document.getElementById("menu").style.display = "none";
		document.getElementById("flashcard").style.display = "block";
	}
	function get_answers() {
		var _answer = answer.value.toLowerCase();
		return _answer.split("/");
	}
	function get_meanings() {
		var _meaning = meaning.innerText.toLowerCase();
		return _meaning.split("/");
	}

	function is_answered() {
		if (answer.value == "") {
			return false;
		}
		return true;
	}

	function add_class(_element, _class) {
		_element.classList.add(_class);
	}
	function remove_class(_element, _class) {
		_element.classList.remove(_class);
	}
	
	function set_corret_answer() {
		add_class(answer, "correct");
		remove_class(answer, "wrong");
		remove_class(answer, "not_answered");
	}
	function set_wrong_answer() {
		remove_class(answer, "correct");
		add_class(answer, "wrong");
		remove_class(answer, "not_answered");
	}
	function clear_answer() {
		answer.value = "";

		remove_class(answer, "correct");
		remove_class(answer, "wrong");
		add_class(answer, "not_answered");
	}

	function show_meaning() {
		add_class(meaning, "visible");
		remove_class(meaning, "hide");
		showMeaning = true;
	}
	function hide_meaning() {
		add_class(meaning, "hide");
		remove_class(meaning, "visible");
		showMeaning = false;
		verifyAnswer = false;		
	}
	
	// Algoritmo was get in the web
	function shuffleArray(_array) {
		for (var i = _array.length - 1; i > 0; i--) {
			var j = Math.floor(Math.random() * (i + 1));
			var temp = _array[i];
			_array[i] = _array[j];
			_array[j] = temp;
		}
	}

	function update_card(_deck) {
		if (pointer == limitSup) {
			card.innerText = "END";
			meaning.innerText = "---";
			return;
		}

		card.innerText = _deck[pointer][0];
		meaning.innerText = _deck[pointer][1];

		console.log(_deck[0],_deck[1]);
	}
	function verify_answer() {
		answers = get_answers();
		meanings = get_meanings();

		var correct = false;

		for (var i = 0; i < answers.length; i++) {
			correct = false;
			for (var j = 0; j < meanings.length; j++) {
				if (answers[i] == meanings[j]) {
					correct = true;
					break;
				}
			}
			
			if (!correct) {
				return false;
			}
		}

		if (!correct) {
			return false;
		}

		return true;
	}

	function previous_word(_deck) {
		pointer--;
		if (pointer < limitInf) {
			pointer = limitInf;
		}
		clear_answer();
		hide_meaning();
		update_card(_deck);
	}
	function next_word(_deck) {
		pointer++;
		if (pointer > limitSup) {
			pointer = limitSup;
			return;
		}
		clear_answer();
		hide_meaning();
		update_card(_deck);
	}

	function eventOldDeck(_key) {
		if (_key == "Enter" && !is_answered()) {
			return;
		}
		if (_key == "ArrowDown" || _key == "Enter") {
			if (pointer == limitSup) {
				return;
			}
			if (pointer == -1) { // Start
				next_word(oldDeck);
				return;
			}
			
			if (!showMeaning) {
				show_meaning();
				var correctAnswer = verify_answer();

				if (correctAnswer) {
					set_corret_answer();
					oldDeck[pointer][2] = 1;
					return;
				}

				set_wrong_answer();
				oldDeck[pointer][2] = 0;
				return;
			}
			console.log(oldDeck);
			next_word(oldDeck);

			if (pointer == limitSup) {
				update_database();
			}
		}
		if (_key == "ArrowUp") {
			previous_word(oldDeck);
		}
	}

	var counterNewDeck = 1;
	function eventNewDeck(_key) {
		if (_key == "Enter" && !is_answered()) {
			return;
		}
		if (_key == "ArrowDown" || _key == "Enter") {
			if (!showMeaning) {
				show_meaning();
				var correctAnswer = verify_answer();

				if (correctAnswer) {
					set_corret_answer();
					newDeck[pointer][2] = 1;
					return;
				}

				set_wrong_answer();
				newDeck[pointer][2] = 0;
				return;
			}
			
			pointer++;
			// Turn back 4 positions
			if (pointer > counterNewDeck) {
				counterNewDeck = pointer;
				pointer = counterNewDeck - 4;
				
				if (pointer < limitInf) {
					pointer = limitInf;
				}
			}
			if (counterNewDeck > limitSup) {
				pointer = limitSup;
				return;
			}
			if (pointer == limitSup) {
				update_database();
			}

			clear_answer();
			hide_meaning();
			update_card(newDeck);
		}
	}
	function eventFunction(_event) {
		if (typeDeck == "old") {
			eventOldDeck(_event.key);
		} else {
			eventNewDeck(_event.key);
		}
	}

	window.addEventListener("keyup", eventFunction);
</script>
</html>